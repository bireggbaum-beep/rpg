<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <title>Kreaturen-Datenbank – Finales Layout</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://bireggbaum-beep.github.io/rpg/styles.css?v=1">
</head>
<body>
    <div class="app-layout">
        <header class="header">
            <label for="file-loader" class="file-label">JSON-Datei laden</label>
            <input type="file" id="file-loader" accept=".json">
            <!-- NEUE BUTTONS -->
            <label for="file-importer" class="file-label" style="background:#4a7c59;">Kreaturen hinzufügen</label>
            <input type="file" id="file-importer" accept=".json">
            <button id="export-btn" style="background:#2c5f7c;">Alle exportieren</button>
            <!-- ENDE NEUE BUTTONS -->
            <span id="file-name" class="muted">Beispieldaten</span>
        </header>
        <aside class="sidebar">
            <div class="search-container">
                <input type="text" id="search-name" placeholder="Nach Name suchen...">
                <input type="text" id="search-type" placeholder="Nach Typ/Trait suchen...">
                <select id="search-hg">
                    <option value="">Alle HG</option>
                </select>
            </div>
            <div class="sidebar-header">
                <h2>Gegner</h2>
                <div class="sort-controls">
                    <button class="sort-btn" id="sort-alpha" title="Alphabetisch sortieren">
                        <svg viewBox="0 0 16 16"><path d="M5.5 3.5v9l-2-2m2 2l2-2M10 4h4m-4 3h3m-3 3h2m-2 3h1"/></svg>
                        A-Z
                    </button>
                    <button class="sort-btn" id="sort-hg" title="Nach HG sortieren">
                        <svg viewBox="0 0 16 16"><path d="M5.5 3.5v9l-2-2m2 2l2-2M10 4h4l-1 2h1l-1 2h1l-1 2h1l-1 2"/></svg>
                        HG
                    </button>
                </div>
            </div>
            <ul id="creature-list"></ul>
        </aside>
        <main class="main-content">
            <div id="out">
                <div id="placeholder">
                    <p>Beispieldaten geladen. Bitte wählen Sie einen Gegner aus der Liste links.</p>
                </div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const $ = s => document.querySelector(s);
            let creatureData = [];
            let currentCreatureIndex = -1;
            let editorVisible = false;
            let currentSort = 'none'; // 'none', 'alpha', 'hg'

            const sampleData = [
                {
                    "name": "Ork-Plünderer",
                    "typ": "Humanoid",
                    "traits": ["Ork"],
                    "hg": 1,
                    "ep": 150,
                    "lp": 22,
                    "sr": 3,
                    "sr_bemerkung": "Felle und rostige Metallplatten",
                    "bew": "5",
                    "pa": 14,
                    "asw": 13,
                    "ini": 1,
                    "rz": 12,
                    "rr": 11,
                    "rw": 10,
                    "pa_bemerkung": [
                        {
                            "icon": "shield",
                            "value": "+1",
                            "description": "Holzschild"
                        }
                    ],
                    "asw_bemerkung": "",
                    "angriffe": [
                        {
                            "name": "Grobes Kriegsbeil",
                            "to_hit": 4,
                            "schaden": "7 (1W8+3)",
                            "zusatz": "Niederschlagen"
                        }
                    ],
                    "besonderheiten": [
                        "Aggressiv: Bewegt sich in seiner Runde immer auf den nächsten Feind zu, wenn möglich."
                    ],
                    "beute": [
                        {
                            "typ": "Schatz",
                            "wurf": "2W8",
                            "beschreibung": "Goldmünzen"
                        },
                        {
                            "typ": "Ausrüstung",
                            "beschreibung": "Grobes Kriegsbeil",
                            "wert": 10
                        },
                        {
                            "typ": "Ausrüstung",
                            "beschreibung": "Holzschild",
                            "wert": 5
                        }
                    ],
                    "beschreibung": "Dieser grimmige, grün-häutige Humanoid starrt dich mit blutunterlaufenen Augen an und entblößt seine hauerartigen Zähne."
                },
                {
                    "name": "Sumpf-Schleicher",
                    "typ": "Tier",
                    "traits": ["Reptil"],
                    "hg": 2,
                    "ep": 200,
                    "lp": 28,
                    "sr": 2,
                    "sr_bemerkung": "Schuppige Haut",
                    "bew": "4 (Schwimmen 6)",
                    "pa": 14,
                    "asw": 14,
                    "ini": 3,
                    "rz": 13,
                    "rr": 14,
                    "rw": 11,
                    "angriffe": [
                        {
                            "name": "Biss",
                            "to_hit": 5,
                            "schaden": "6 (1W8+2)"
                        },
                        {
                            "name": "Giftspucke",
                            "to_hit": 5,
                            "schaden": "3 (1W4+1)",
                            "reichweite": "3xLang",
                            "anzahl": 2,
                            "zusatz": "Ziel wird verlangsamt",
                            "rettungswurf": {
                                "art": "RZ",
                                "zw": 13,
                                "bei_misserfolg": "1 Runde verlangsamt"
                            }
                        }
                    ],
                    "besonderheiten": [
                        "Sumpftarnung: Hat einen Vorteil bei Verstecken-Proben in Sumpfgebieten."
                    ],
                    "beute": [
                        {
                            "typ": "Schatz",
                            "wurf": "3W6",
                            "beschreibung": "Goldmünzen"
                        },
                        {
                            "typ": "Zutaten",
                            "beschreibung": "Giftzahn",
                            "wert": 25
                        },
                        {
                            "typ": "Zutaten",
                            "beschreibung": "Schuppenhaut (1W4 Stück)",
                            "wert": 10
                        }
                    ],
                    "beschreibung": "Diese große, echsenartige Kreatur hat eine schlammverkrustete, moosgrüne Haut."
                },
                {
                    "name": "Gruftschrecken",
                    "typ": "Untot",
                    "traits": ["Geist", "Körperlos"],
                    "hg": 3,
                    "ep": 350,
                    "lp": 35,
                    "sr": 4,
                    "sr_bemerkung": "Körperlos",
                    "bew": "0 (Flug 6)",
                    "pa": 15,
                    "asw": 15,
                    "ini": 2,
                    "rz": "immun",
                    "rr": 13,
                    "rw": "immun",
                    "angriffe": [
                        {
                            "name": "Berührung der Verzweiflung",
                            "to_hit": 5,
                            "schaden": "7 (2W6)",
                            "zusatz": "Ziel wird furchtsam",
                            "rettungswurf": {
                                "art": "RW",
                                "zw": 14,
                                "bei_misserfolg": "Ziel wird furchtsam für 1W4 Runden"
                            }
                        },
                        {
                            "name": "Dunkle Stärkung",
                            "isSpell": true,
                            "reichweite": "8",
                            "anzahl": 2,
                            "beschreibung": "Verbündeter erhält +2 auf Angriff und Schaden für 3 Runden"
                        }
                    ],
                    "besonderheiten": [
                        "Körperlos: Kann sich durch Kreaturen und Objekte bewegen."
                    ],
                    "beute": [
                        {
                            "typ": "Zutaten",
                            "beschreibung": "Ektoplasma-Rest",
                            "wert": 40
                        }
                    ],
                    "beschreibung": "Ein kalter Hauch erfüllt den Raum, kurz bevor diese durchscheinende Gestalt erscheint."
                }
            ];

            // Hilfsfunktionen für Parsing / Vergleich
            function parseNumberOrNull(val) {
                if (val === null || val === undefined || val === "") return null;
                const n = Number(val);
                return Number.isFinite(n) ? n : null;
            }

            function parseIntOrNull(val) {
                if (val === null || val === undefined || val === "") return null;
                const n = parseInt(val, 10);
                return Number.isFinite(n) ? n : null;
            }

            function normalizeHg(hg) {
                if (hg === null || hg === undefined || hg === "") return Number.POSITIVE_INFINITY;
                // If numeric already
                if (typeof hg === 'number') return hg;
                const s = String(hg).trim();
                // fraction like "1/2"
                if (s.includes('/')) {
                    const parts = s.split('/');
                    const num = parseFloat(parts[0]);
                    const den = parseFloat(parts[1]);
                    if (!isNaN(num) && !isNaN(den) && den !== 0) return num / den;
                    return Number.POSITIVE_INFINITY;
                }
                // plain number string
                const n = parseFloat(s);
                if (!isNaN(n)) return n;
                return Number.POSITIVE_INFINITY;
            }

            // canonicalize object to deterministic JSON string (sorted keys) for content-based duplicate detection
            function canonicalize(obj) {
                if (obj === null || typeof obj !== 'object') return JSON.stringify(obj);
                if (Array.isArray(obj)) return '[' + obj.map(canonicalize).join(',') + ']';
                const keys = Object.keys(obj).sort();
                return '{' + keys.map(k => JSON.stringify(k) + ':' + canonicalize(obj[k])).join(',') + '}';
            }

            // Create a "key" for duplicates: prefer normalized name|type|hg, but also include content hash for inhaltliche redundanz
            function getCreatureKey(c) {
                const name = (c.name || "").trim().toLowerCase();
                const typ = (c.typ || "").trim().toLowerCase();
                const hg = c.hg === null || c.hg === undefined ? "" : String(c.hg).trim().toLowerCase();
                // base key
                const base = `${name}|${typ}|${hg}`;
                // content signature
                const contentSig = canonicalize(c);
                return `${base}||${contentSig}`;
            }

            function init() {
                creatureData = sampleData;
                populateHgFilter();
                filterAndPopulateSidebar();
                $("#file-name").textContent = "Beispieldaten";

                $("#file-loader").addEventListener("change", handleFileLoad);
                $("#search-name").addEventListener("input", filterAndPopulateSidebar);
                $("#search-type").addEventListener("input", filterAndPopulateSidebar);
                $("#search-hg").addEventListener("change", filterAndPopulateSidebar);

                // NEUE SORTIER-BUTTONS
                $("#sort-alpha").addEventListener("click", () => handleSort('alpha'));
                $("#sort-hg").addEventListener("click", () => handleSort('hg'));

                // Import/Export Event Listener
                if ($("#file-importer")) {
                    $("#file-importer").addEventListener("change", handleFileImport);
                }
                if ($("#export-btn")) {
                    $("#export-btn").addEventListener("click", exportAllCreatures);
                }
            }

            function handleFileLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                $("#file-name").textContent = file.name;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (!Array.isArray(data)) throw new Error("Die JSON-Datei muss ein Array von Gegner-Objekten enthalten.");
                        creatureData = data;
                        populateHgFilter();
                        filterAndPopulateSidebar();
                        $("#out").innerHTML = `<div id="placeholder"><p>Daten geladen. Bitte wählen Sie einen Gegner aus der Liste links.</p></div>`;
                    } catch (err) {
                        alert(`Fehler beim Lesen der Datei: ${err.message}`);
                        creatureData = [];
                        filterAndPopulateSidebar();
                        $("#out").innerHTML = `<div id="placeholder"><p class="error">Fehler: ${err.message}</p></div>`;
                    }
                };
                reader.readAsText(file);
                // reset input so same file can be loaded again if needed
                event.target.value = '';
            }

            // NEUE FUNKTION: Kreaturen importieren und zur bestehenden Liste hinzufügen (mit Duplikat-Prüfung)
            function handleFileImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (!Array.isArray(data)) throw new Error("Die JSON-Datei muss ein Array von Gegner-Objekten enthalten.");

                        // Build sets of existing signatures (using canonicalized content + base keys)
                        const existingBaseKeys = new Set(creatureData.map(c => {
                            const name = (c.name || "").trim().toLowerCase();
                            const typ = (c.typ || "").trim().toLowerCase();
                            const hg = c.hg === null || c.hg === undefined ? "" : String(c.hg).trim().toLowerCase();
                            return `${name}|${typ}|${hg}`;
                        }));
                        const existingContentSigs = new Set(creatureData.map(c => canonicalize(c)));

                        const toAdd = [];
                        const skipped = [];
                        const ambiguous = []; // if entries lack identifying data but content differs

                        data.forEach(item => {
                            const baseKey = `${(item.name || "").trim().toLowerCase()}|${(item.typ || "").trim().toLowerCase()}|${(item.hg === null || item.hg === undefined ? "" : String(item.hg).trim().toLowerCase())}`;
                            const contentSig = canonicalize(item);
                            // Duplicate if identical content OR same baseKey and baseKey not empty
                            if (existingContentSigs.has(contentSig)) {
                                skipped.push({ item, reason: 'vollständiger Inhalt bereits vorhanden' });
                            } else if (baseKey !== "||" && baseKey.split('|').some(s => s !== "") && existingBaseKeys.has(baseKey)) {
                                // same name/type/hg already present -> treat as duplicate (inhaltlich redundant)
                                skipped.push({ item, reason: 'Name/Typ/HG bereits vorhanden' });
                            } else {
                                // new entry
                                toAdd.push(item);
                                existingContentSigs.add(contentSig);
                                if (baseKey !== "||") existingBaseKeys.add(baseKey);
                            }
                        });

                        const beforeCount = creatureData.length;
                        creatureData = [...creatureData, ...toAdd];
                        populateHgFilter();
                        filterAndPopulateSidebar();

                        // Summary
                        const addedCount = toAdd.length;
                        const skippedCount = skipped.length;
                        const msg = `${addedCount} Kreatur(en) hinzugefügt.\n${skippedCount} Eintrag(e) übersprungen (Duplikate).\nGesamt: ${creatureData.length} Kreaturen.`;
                        alert(msg);
                        $("#file-name").textContent = `${beforeCount} + ${addedCount} Kreaturen (import)`;

                    } catch (err) {
                        alert(`Fehler beim Importieren: ${err.message}`);
                    } finally {
                        // Input zurücksetzen, damit dieselbe Datei erneut importiert werden kann
                        event.target.value = '';
                    }
                };
                reader.readAsText(file);
            }

            // Erweiterte filterAndPopulateSidebar Funktion
            function filterAndPopulateSidebar() {
                const nameFilter = ($("#search-name").value || "").toLowerCase();
                const typeFilter = ($("#search-type").value || "").toLowerCase();
                const hgFilter = $("#search-hg").value;

                let filteredCreatures = creatureData.filter(creature => {
                    const nameMatch = (creature.name || "").toLowerCase().includes(nameFilter);
                    const typeString = (creature.typ || "").toLowerCase();
                    const traitsString = (creature.traits || []).join(" ").toLowerCase();
                    const typeMatch = typeString.includes(typeFilter) || traitsString.includes(typeFilter);
                    const hgMatch = !hgFilter || String(creature.hg) === hgFilter;
                    return nameMatch && typeMatch && hgMatch;
                });

                // Sortierung anwenden
                if (currentSort === 'alpha') {
                    filteredCreatures.sort((a, b) => {
                        const nameA = (a.name || "").toLowerCase();
                        const nameB = (b.name || "").toLowerCase();
                        return nameA.localeCompare(nameB, 'de');
                    });
                } else if (currentSort === 'hg') {
                    filteredCreatures.sort((a, b) => {
                        const hgA = normalizeHg(a.hg);
                        const hgB = normalizeHg(b.hg);
                        if (hgA === hgB) {
                            // Bei gleichem HG alphabetisch sortieren
                            return (a.name || "").localeCompare(b.name || "", 'de');
                        }
                        return hgA - hgB;
                    });
                }

                populateSidebar(filteredCreatures);
            }

            // Neue Funktion für Sortier-Buttons
            function handleSort(sortType) {
                // Alle Buttons deaktivieren
                document.querySelectorAll('.sort-btn').forEach(btn => {
                    btn.classList.remove('active');
                });

                if (currentSort === sortType) {
                    // Wenn bereits aktiv, Sortierung aufheben
                    currentSort = 'none';
                } else {
                    // Neue Sortierung aktivieren
                    currentSort = sortType;
                    const el = document.getElementById(`sort-${sortType}`);
                    if (el) el.classList.add('active');
                }

                filterAndPopulateSidebar();
            }

            // NEUE FUNKTION: Alle Kreaturen als JSON exportieren
            function exportAllCreatures() {
                if (creatureData.length === 0) {
                    alert("Keine Kreaturen zum Exportieren vorhanden.");
                    return;
                }

                // JSON-String erstellen
                const jsonStr = JSON.stringify(creatureData, null, 2);

                // Blob erstellen
                const blob = new Blob([jsonStr], { type: 'application/json' });

                // Download-Link erstellen
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');

                // Dateiname mit Timestamp
                const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                a.download = `kreaturen_export_${timestamp}.json`;
                a.href = url;

                // Download auslösen
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // URL freigeben
                URL.revokeObjectURL(url);

                // Bestätigungsmeldung (optional)
                console.log(`${creatureData.length} Kreatur(en) wurden exportiert.`);
            }

            function populateHgFilter() {
                const hgSelect = $("#search-hg");
                // Collect unique HG values as strings, keep possible fractional and textual values
                const rawValues = [...new Set(creatureData.map(c => (c.hg === null || c.hg === undefined ? "" : String(c.hg))).filter(s => s !== ""))];
                // Sort by normalized numeric value where possible, otherwise by locale
                rawValues.sort((a, b) => {
                    const na = normalizeHg(a);
                    const nb = normalizeHg(b);
                    if (na === nb) return String(a).localeCompare(String(b), 'de');
                    return na - nb;
                });

                hgSelect.innerHTML = '<option value="">Alle HG</option>';
                rawValues.forEach(hg => {
                    const option = document.createElement("option");
                    option.value = hg;
                    option.textContent = `HG ${hg}`;
                    hgSelect.appendChild(option);
                });
            }

            function populateSidebar(creatures) {
                const list = $("#creature-list");
                list.innerHTML = "";

                if (creatures.length === 0) {
                    list.innerHTML = '<li style="text-align:center; color: var(--muted); font-style: italic;">Keine Treffer</li>';
                    return;
                }

                creatures.forEach(creature => {
                    const originalIndex = creatureData.findIndex(c => c === creature);
                    const li = document.createElement("li");

                    // ANPASSUNG: Strukturierter Inhalt mit Name, Typ und HG
                    const name = creature.name || `Unbenannter Gegner ${originalIndex + 1}`;
                    const typ = creature.typ || "Unbekannt";
                    const hg = creature.hg != null ? `HG ${creature.hg}` : "HG –";

                    li.innerHTML = `
                        <div class="creature-name">${name}</div>
                        <div class="creature-meta">
                            <span class="creature-type">${typ}</span>
                            <span class="creature-hg">${hg}</span>
                        </div>
                    `;

                    li.dataset.index = originalIndex;
                    li.addEventListener("click", () => {
                        document.querySelectorAll("#creature-list li").forEach(item => item.classList.remove("active"));
                        li.classList.add("active");
                        currentCreatureIndex = originalIndex;
                        renderStatblock(creatureData[originalIndex]);
                        editorVisible = false;
                        const editor = document.querySelector("#inline-editor");
                        if (editor) {
                            editor.classList.remove("visible");
                        }
                    });
                    list.appendChild(li);
                });
            }

            // ANPASSUNG 1 & 2: Verbessertes Attack-Line Rendering
function naturalAttackLine(a) {
    let namePart = a.name || 'Unbenannte Fähigkeit';
    
    if (a.anzahl) {
        namePart = `${a.anzahl}x ${namePart}`;
    }

    let line = `<b>${namePart}</b>`;
    const details = [];

    // Schritt 1: Schaden immer zuerst hinzufügen, falls vorhanden.
    if (a.schaden) {
        details.push(`${a.schaden} Schaden`);
    }

    // Schritt 2: Angriffswurf hinzufügen, falls vorhanden.
    if (a.to_hit != null) {
        details.unshift(`${plusify(a.to_hit)} zum Treffen`); // unshift stellt es an den Anfang
    }

    // Schritt 3: Rettungswurf und Zusatzeffekte intelligent kombinieren.
    const hasSave = a.rettungswurf && a.rettungswurf.art && a.rettungswurf.zw;
    
    if (hasSave) {
        const r = a.rettungswurf;
        let saveText = `(Rettungswurf ${r.art} ${txt(r.zw)}`;

        // Wenn es einen Zusatzeffekt gibt (z.B. "Niederschlagen")
        if (a.zusatz) {
            const folge = r.bei_misserfolg || a.zusatz;
            saveText += ` oder ${folge})`;
        } 
        // Wenn es nur um Schaden geht (z.B. "halber Schaden")
        else if (a.schaden) {
            const erfolg = r.bei_erfolg || 'halber Schaden';
            saveText += ` für ${erfolg})`;
        } 
        // Allgemeiner Fall
        else {
            saveText += ` oder Effekt tritt ein)`;
        }
        details.push(saveText);
    } 
    // Wenn es keinen Rettungswurf gibt, aber einen Zusatzeffekt
    else if (a.zusatz) {
        details.push(a.zusatz);
    }

    if (details.length > 0) {
        line += ` ${details.join(', ')}`;
    }

    // Schritt 4: Reichweite immer am Ende hinzufügen.
    if (a.reichweite) {
        line += ` (Reichweite: ${a.reichweite})`;
    }

    return line;
}


            // ANPASSUNG 3: Verbessertes Beute-Rendering
            function renderLoot(beute) {
                if (!beute || beute.length === 0) return '<span class="muted">Keine.</span>';

                // Gruppiere Beute-Einträge nach ihrem Typ
                const lootGroups = beute.reduce((acc, item) => {
                    const typ = item.typ || 'Unbekannt';
                    if (!acc[typ]) {
                        acc[typ] = [];
                    }
                    acc[typ].push(item);
                    return acc;
                }, {});

                let html = "";

                // Definiere die Reihenfolge und Titel der Kategorien
                const categoryOrder = [
                    { key: 'Schatz', title: 'Schatz' },
                    { key: 'Ausrüstung', title: 'Ausrüstung' },
                    { key: 'Zutaten', title: 'Zutaten (erntbar)' }
                ];

                categoryOrder.forEach(category => {
                    const items = lootGroups[category.key];
                    if (items && items.length > 0) {
                        html += `<div class="loot-category"><b>${category.title}:</b></div>`;
                        
                        items.forEach(item => {
                            // Jeder 'item' ist ein Wurf
                            html += '<div class="loot-item">';
                            
                            // Hauptzeile für den Wurf
                            let mainLine = '';
                            if (item.wurf) mainLine += `<span class="muted">${item.wurf}</span> `;
                            mainLine += item.beschreibung || "Gegenstand";
                            html += `<div>${mainLine}</div>`;

                            // Prüfe auf 'optionen' und rendere sie, falls vorhanden
                            if (Array.isArray(item.optionen) && item.optionen.length > 0) {
                                html += '<div class="loot-options">';
                                item.optionen.forEach(opt => {
                                    let optLine = `<span class="muted">(Bei ${opt.bedingung || '?'})</span> `;
                                    if (opt.anzahl && opt.anzahl > 1) optLine += `${opt.anzahl}x `;
                                    optLine += opt.name || 'Unbekannter Gegenstand';
                                    if (opt.wert) optLine += ` (Wert: ${opt.wert} GM)`;
                                    html += `<div class="loot-option-item">${optLine}</div>`;
                                });
                                html += '</div>';
                            } else if (item.wert) {
                                // Fallback für einfache Items ohne 'optionen', aber mit Wert
                                html = html.slice(0, -6); // entferne letztes </div>
                                html += ` (Wert: ${item.wert} GM)</div>`;
                            }
                            
                            html += '</div>';
                        });
                    }
                });

                return html || '<span class="muted">Keine.</span>';
            }


            function renderStatblock(d) {
                const res = parseRes(d.besonderheiten || []);
                const traits = Array.isArray(d.traits) ? d.traits : [];
                const srNote = formatNote(d.sr_bemerkung);
                const aswNote = formatNote(d.asw_bemerkung);
                const paNote = formatPaNote(d.pa_bemerkung || []);
                const hasBes = res.imm.length || res.res.length || res.weak.length || res.other.length;

                $("#out").innerHTML = `
                    <div class="head">
                        <button class="edit-btn">Bearbeiten</button>
                        <div class="name">${txt(d.name)}</div>
                        <div class="line">
                            ${d.hg != null ? `<span class="hg-badge">HG ${txt(d.hg)}</span>` : ""}
                            ${d.typ ? `<span class="chip">${d.typ}</span>` : ""}
                            ${traits.map(t => `<span class="chip">${t}</span>`).join("")}
                            ${d.ep != null ? `<span class="chip">${d.ep} EP</span>` : ""}
                        </div>
                        ${d.beschreibung ? `<div class="desc">${d.beschreibung}</div>` : ""}
                    </div>
                    <div class="sec">
                        <div class="row"><b>Lebenspunkte</b> ${txt(d.lp)}</div>
                        <div class="row"><b>Bewegung</b> ${fmtBew(d.bew)}; <b>INI</b> ${plusify(d.ini)}</div>
                    </div>
                    <div class="sec">
                        <h3>Verteidigung</h3>
                        <div class="row"><b>Abwehr Nahkampf (PA)</b> ${txt(d.pa)}${paNote}</div>
                        <div class="row"><b>Abwehr Fernkampf (ASW)</b> ${txt(d.asw)}${aswNote}</div>
                        <div class="row"><b>Schadensreduktion</b> ${txt(d.sr)}${srNote}</div>
                        <div class="rettungswuerfe">
                            <span><b>Zähigkeit</b> ${plusify(d.rz, true)}</span><span>|</span>
                            <span><b>Reflexe</b> ${plusify(d.rr, true)}</span><span>|</span>
                            <span><b>Willenskraft</b> ${plusify(d.rw, true)}</span>
                        </div>
                    </div>
                    ${Array.isArray(d.angriffe) && d.angriffe.length ? `<div class="sec"><h3>Angriffe</h3><div class="attblock">${d.angriffe.map(a => `<div class="attline">${naturalAttackLine(a)}</div>`).join("")}</div></div>` : ""}
                    ${hasBes ? `<div class="sec"><h3>Besonderheiten</h3>${res.imm.map(x=>`<div class="row">${x}</div>`).join("")}${res.res.map(x=>`<div class="row">${x}</div>`).join("")}${res.weak.map(x=>`<div class="row">${x}</div>`).join("")}${res.other.map(x=>`<div class="row">${x}</div>`).join("")}</div>` : ""}
                    <div class="sec"><h3>Beute</h3>${renderLoot(d.beute || [])}</div>
                    
                    <div class="inline-editor" id="inline-editor">
                        <div class="editor-header">
                            <h3>Kreatur bearbeiten</h3>
                            <button class="close-btn">Schließen</button>
                        </div>
                        <div class="editor-body">
                            ${renderEditorForm(d)}
                        </div>
                        <div class="editor-footer">
                            <button class="save-btn">Speichern</button>
                            <button class="cancel-btn">Abbrechen</button>
                            <button class="delete-btn" style="background:#b63b3b; color:#fff; margin-left:8px;">Löschen</button>
                        </div>
                    </div>
                `;

                // Event Listener hinzufügen
                document.querySelector(".edit-btn").addEventListener("click", toggleEditor);
                document.querySelector(".close-btn").addEventListener("click", toggleEditor);
                document.querySelector(".cancel-btn").addEventListener("click", toggleEditor);
                document.querySelector(".save-btn").addEventListener("click", saveCreature);
                
                // Delete listener
                const delBtn = document.querySelector(".delete-btn");
                if (delBtn) {
                    delBtn.addEventListener("click", () => {
                        if (currentCreatureIndex === -1 || currentCreatureIndex === undefined) return;
                        const name = creatureData[currentCreatureIndex]?.name || "diese Kreatur";
                        if (!confirm(`Kreatur "${name}" wirklich löschen? Diese Aktion kann nicht rückgängig gemacht werden.`)) return;
                        deleteCreature(currentCreatureIndex);
                    });
                }

                // Event Listener für Add-Buttons
                document.querySelectorAll(".add-btn").forEach(btn => {
                    btn.addEventListener("click", (e) => {
                        const parent = e.target.parentElement;
                        if (parent.querySelector("#edit-angriffe-container")) {
                            addAttackField();
                        } else if (parent.querySelector("#edit-besonderheiten-container")) {
                            addBesonderheitField();
                        } else if (parent.querySelector("#edit-beute-container")) {
                            addLootField();
                        }
                    });
                });
            }

            function toggleEditor() {
                editorVisible = !editorVisible;
                const editor = document.querySelector("#inline-editor");
                if (editorVisible) {
                    editor.classList.add("visible");
                    populateEditor(creatureData[currentCreatureIndex]);
                } else {
                    editor.classList.remove("visible");
                }
            }

            function populateEditor(creature) {
                if (!creature) return;

                document.querySelector("#edit-name").value = creature.name || "";
                document.querySelector("#edit-hg").value = creature.hg || "";
                document.querySelector("#edit-typ").value = creature.typ || "";
                document.querySelector("#edit-traits").value = (creature.traits || []).join(", ");
                document.querySelector("#edit-ep").value = creature.ep || "";
                document.querySelector("#edit-beschreibung").value = creature.beschreibung || "";

                document.querySelector("#edit-lp").value = creature.lp || "";
                document.querySelector("#edit-bew").value = creature.bew || "";
                document.querySelector("#edit-ini").value = creature.ini || "";

                document.querySelector("#edit-pa").value = creature.pa || "";

                // PA Bemerkung Felder
                const textPaBemerkung = (creature.pa_bemerkung || []).filter(note => typeof note === 'string').join("; ");
                document.querySelector("#edit-pa-bemerkung").value = textPaBemerkung;

                const shield = (creature.pa_bemerkung || []).find(item => item.icon === "shield");
                document.querySelector("#edit-pa-shield-value").value = shield ? shield.value : "";
                document.querySelector("#edit-pa-shield-desc").value = shield ? shield.description : "";

                document.querySelector("#edit-asw").value = creature.asw || "";
                document.querySelector("#edit-asw-bemerkung").value = creature.asw_bemerkung || "";
                document.querySelector("#edit-sr").value = creature.sr || "";
                document.querySelector("#edit-sr-bemerkung").value = creature.sr_bemerkung || "";
                document.querySelector("#edit-rz").value = creature.rz || "";
                document.querySelector("#edit-rr").value = creature.rr || "";
                document.querySelector("#edit-rw").value = creature.rw || "";

                const attacksContainer = document.querySelector("#edit-angriffe-container");
                attacksContainer.innerHTML = "";
                (creature.angriffe || []).forEach(attack => addAttackField(attack));

                const besonderheitenContainer = document.querySelector("#edit-besonderheiten-container");
                besonderheitenContainer.innerHTML = "";
                (creature.besonderheiten || []).forEach(besonderheit => addBesonderheitField(besonderheit));

                const lootContainer = document.querySelector("#edit-beute-container");
                lootContainer.innerHTML = "";
                (creature.beute || []).forEach(loot => addLootField(loot));

                const editHgSelect = document.querySelector("#edit-hg");
                editHgSelect.innerHTML = "";
                for (let i = 0; i <= 20; i++) {
                    const option = document.createElement("option");
                    option.value = i;
                    option.textContent = `HG ${i}`;
                    editHgSelect.appendChild(option);
                }
                // If creature.hg is non-numeric (like "1/2"), ensure the select contains that value to show it
                const hgVal = creature.hg;
                if (hgVal !== null && hgVal !== undefined && String(hgVal) !== "") {
                    const exists = Array.from(editHgSelect.options).some(o => o.value == String(hgVal));
                    if (!exists) {
                        const opt = document.createElement("option");
                        opt.value = String(hgVal);
                        opt.textContent = `HG ${hgVal}`;
                        // put it at the top so it's visible/selected
                        editHgSelect.insertBefore(opt, editHgSelect.firstChild);
                    }
                    editHgSelect.value = String(hgVal);
                } else {
                    editHgSelect.value = 0;
                }
            }

              function addAttackField(attack = {}) {
                const container = document.querySelector("#edit-angriffe-container");
                const div = document.createElement("div");
                div.classList.add("dynamic-item", "attack-editor-item");

                div.innerHTML = `
                    <div class="form-row" style="width:100%;">
                        <div class="form-group large"><label>Name des Angriffs / Fähigkeit</label><input type="text" class="edit-attack-name" value="${attack.name || ""}"></div>
                        <div class="form-group medium"><label>Reichweite</label><input type="text" class="edit-attack-reichweite" value="${attack.reichweite || ""}" placeholder="z.B. 2xLang"></div>
                        <div class="form-group small"><label>Anzahl</label><input type="number" class="edit-attack-anzahl" value="${attack.anzahl || ""}" placeholder="pro Kampf"></div>
                    </div>
                    
                    <div class="form-row" style="width:100%;">
                        <div class="form-group small"><label>Angriffsbonus</label><input type="number" class="edit-attack-to-hit" value="${attack.to_hit ?? ''}" placeholder="+X"></div>
                        <div class="form-group medium"><label>Schaden</label><input type="text" class="edit-attack-schaden" value="${attack.schaden || ''}" placeholder="z.B. 8 (2W6+1)"></div>
                        <div class="form-group full"><label>Effekt-Name</label><input type="text" class="edit-attack-zusatz" value="${attack.zusatz || ''}" placeholder="z.B. Niederschlagen, Gift"></div>
                    </div>

                    <div class="rettungswurf-group" style="width:100%;">
                        <h5>Rettungswurf (falls zutreffend)</h5>
                        <div class="form-row">
                            <div class="form-group small">
                                <label>Art</label>
                                <select class="edit-attack-rw-art">
                                    <option value="">Keine</option>
                                    <option value="RZ" ${attack.rettungswurf?.art === "RZ" ? "selected" : ""}>RZ (Zähigkeit)</option>
                                    <option value="RR" ${attack.rettungswurf?.art === "RR" ? "selected" : ""}>RR (Reflexe)</option>
                                    <option value="RW" ${attack.rettungswurf?.art === "RW" ? "selected" : ""}>RW (Willenskraft)</option>
                                </select>
                            </div>
                            <div class="form-group small"><label>Zielwert (ZW)</label><input type="number" class="edit-attack-rw-zw" value="${attack.rettungswurf?.zw || ""}"></div>
                            <div class="form-group medium"><label>Bei Erfolg</label><input type="text" class="edit-attack-rw-erfolg" value="${attack.rettungswurf?.bei_erfolg || 'halber Schaden'}" placeholder="z.B. halber Schaden"></div>
                            <div class="form-group medium"><label>Folge bei Misserfolg</label><input type="text" class="edit-attack-rw-misserfolg" value="${attack.rettungswurf?.bei_misserfolg || ''}" placeholder="z.B. Ziel geht zu Boden"></div>
                        </div>
                    </div>
                    <button type="button" class="remove-btn">×</button>
                `;

                div.querySelector(".remove-btn").addEventListener("click", () => div.remove());
                container.appendChild(div);
            }


            function addBesonderheitField(besonderheit = "") {
                const container = document.querySelector("#edit-besonderheiten-container");
                const div = document.createElement("div");
                div.classList.add("dynamic-item");
                div.innerHTML = `
                    <div class="form-group full"><label>Besonderheit</label><textarea class="edit-besonderheit-text">${besonderheit}</textarea></div>
                    <button class="remove-btn">×</button>
                `;
                div.querySelector(".remove-btn").addEventListener("click", () => div.remove());
                container.appendChild(div);
            }

            // ANPASSUNG 3: Dropdown für Beute-Typ
            function addLootField(loot = {}) {
                const container = document.querySelector("#edit-beute-container");
                const div = document.createElement("div");
                div.classList.add("dynamic-item", "loot-editor-item");
                
                let optionsHTML = '';
                if (Array.isArray(loot.optionen)) {
                    loot.optionen.forEach(opt => {
                        optionsHTML += `
                            <div class="dynamic-sub-item">
                                <input type="text" class="edit-loot-opt-bedingung" placeholder="Bedingung (z.B. 1-2)" value="${opt.bedingung || ''}">
                                <input type="text" class="edit-loot-opt-name" placeholder="Item-Name" value="${opt.name || ''}">
                                <input type="number" class="edit-loot-opt-anzahl" placeholder="Anz." value="${opt.anzahl || ''}">
                                <input type="number" class="edit-loot-opt-wert" placeholder="Wert" value="${opt.wert || ''}">
                                <button type="button" class="remove-btn sub-remove-btn">×</button>
                            </div>
                        `;
                    });
                }

                div.innerHTML = `
                    <div class="form-row" style="width:100%;">
                        <div class="form-group medium">
                            <label>Typ</label>
                            <select class="edit-loot-typ">
                                <option value="Schatz" ${loot.typ === "Schatz" ? "selected" : ""}>Schatz</option>
                                <option value="Ausrüstung" ${loot.typ === "Ausrüstung" ? "selected" : ""}>Ausrüstung</option>
                                <option value="Zutaten" ${loot.typ === "Zutaten" ? "selected" : ""}>Zutaten (erntbar)</option>
                            </select>
                        </div>
                        <div class="form-group full"><label>Beschreibung des Wurfs</label><input type="text" class="edit-loot-beschreibung" value="${loot.beschreibung || ""}" placeholder="z.B. Waffen, Goldmünzen"></div>
                        <div class="form-group medium"><label>Würfelwurf</label><input type="text" class="edit-loot-wurf" value="${loot.wurf || ""}" placeholder="z.B. (W6|1-4)"></div>
                    </div>
                    <div class="form-row" style="width:100%;">
                        <div class="form-group small"><label>Wert (einfach)</label><input type="number" class="edit-loot-wert" value="${loot.wert || ''}" placeholder="Nur für simple Drops"></div>
                        <div class="form-group small"><label>Anzahl (einfach)</label><input type="number" class="edit-loot-anzahl" value="${loot.anzahl || ''}" placeholder="Nur für simple Drops"></div>
                    </div>
                    <div class="loot-options-editor" style="width:100%; margin-top: 8px;">
                        <label style="font-weight:bold; font-size:11px; color:var(--muted);">Optionen (für 'oder'-Beute)</label>
                        <div class="loot-options-container">${optionsHTML}</div>
                        <button type="button" class="add-btn add-option-btn">+ Option hinzufügen</button>
                    </div>
                    <button type="button" class="remove-btn loot-remove-btn">×</button>
                `;

                // Event Listener für den Haupt-Löschen-Button
                div.querySelector(".loot-remove-btn").addEventListener("click", () => div.remove());

                // Event Listener für den "+ Option"-Button
                div.querySelector(".add-option-btn").addEventListener("click", (e) => {
                    const optionsContainer = e.target.previousElementSibling;
                    const subItem = document.createElement('div');
                    subItem.className = 'dynamic-sub-item';
                    subItem.innerHTML = `
                        <input type="text" class="edit-loot-opt-bedingung" placeholder="Bedingung (z.B. 1-2)">
                        <input type="text" class="edit-loot-opt-name" placeholder="Item-Name">
                        <input type="number" class="edit-loot-opt-anzahl" placeholder="Anz.">
                        <input type="number" class="edit-loot-opt-wert" placeholder="Wert">
                        <button type="button" class="remove-btn sub-remove-btn">×</button>
                    `;
                    subItem.querySelector('.sub-remove-btn').addEventListener('click', () => subItem.remove());
                    optionsContainer.appendChild(subItem);
                });

                // Event Listener für bereits existierende Sub-Item-Löschen-Buttons
                div.querySelectorAll('.sub-remove-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => e.target.parentElement.remove());
                });

                container.appendChild(div);
            }


            function saveCreature() {
                const creature = creatureData[currentCreatureIndex];
                if (!creature) return;

                // Allgemein, Grundwerte, Verteidigung (bleibt gleich)
                creature.name = document.querySelector("#edit-name").value;
                const hgRaw = document.querySelector("#edit-hg").value;
                creature.hg = isNaN(parseFloat(hgRaw)) ? hgRaw : parseFloat(hgRaw);
                creature.typ = document.querySelector("#edit-typ").value;
                creature.traits = document.querySelector("#edit-traits").value.split(",").map(t => t.trim()).filter(t => t);
                creature.ep = parseNumberOrNull(document.querySelector("#edit-ep").value);
                creature.beschreibung = document.querySelector("#edit-beschreibung").value;
                creature.lp = parseNumberOrNull(document.querySelector("#edit-lp").value);
                creature.bew = document.querySelector("#edit-bew").value;
                creature.ini = parseNumberOrNull(document.querySelector("#edit-ini").value);
                creature.pa = parseNumberOrNull(document.querySelector("#edit-pa").value);
                creature.pa_bemerkung = [];
                const textPaBemerkung = document.querySelector("#edit-pa-bemerkung").value;
                if (textPaBemerkung) {
                    textPaBemerkung.split(";").forEach(note => {
                        if (note.trim()) creature.pa_bemerkung.push(note.trim());
                    });
                }
                const shieldValue = document.querySelector("#edit-pa-shield-value").value;
                const shieldDesc = document.querySelector("#edit-pa-shield-desc").value;
                if (shieldValue || shieldDesc) {
                    creature.pa_bemerkung.push({ icon: "shield", value: shieldValue, description: shieldDesc });
                }
                creature.asw = parseNumberOrNull(document.querySelector("#edit-asw").value);
                creature.asw_bemerkung = document.querySelector("#edit-asw-bemerkung").value;
                creature.sr = parseNumberOrNull(document.querySelector("#edit-sr").value);
                creature.sr_bemerkung = document.querySelector("#edit-sr-bemerkung").value;
                creature.rz = document.querySelector("#edit-rz").value;
                creature.rr = document.querySelector("#edit-rr").value;
                creature.rw = document.querySelector("#edit-rw").value;
                creature.besonderheiten = Array.from(document.querySelectorAll("#edit-besonderheiten-container .edit-besonderheit-text")).map(el => el.value).filter(Boolean);

                // Angriffe speichern (NEUE LOGIK)
                creature.angriffe = [];
                document.querySelectorAll("#edit-angriffe-container .dynamic-item").forEach(item => {
                    const attack = {
                        name: item.querySelector(".edit-attack-name").value,
                        to_hit: parseNumberOrNull(item.querySelector(".edit-attack-to-hit").value),
                        schaden: item.querySelector(".edit-attack-schaden").value || null,
                        reichweite: item.querySelector(".edit-attack-reichweite").value || null,
                        anzahl: parseNumberOrNull(item.querySelector(".edit-attack-anzahl").value),
                        zusatz: item.querySelector(".edit-attack-zusatz").value || null,
                    };

                    // Leere Felder aus dem Objekt entfernen für sauberes JSON
                    Object.keys(attack).forEach(key => (attack[key] === null || attack[key] === '') && delete attack[key]);

                    const rwArt = item.querySelector(".edit-attack-rw-art").value;
                    if (rwArt) {
                        attack.rettungswurf = {
                            art: rwArt,
                            zw: parseNumberOrNull(item.querySelector(".edit-attack-rw-zw").value),
                            bei_erfolg: item.querySelector(".edit-attack-rw-erfolg").value || null,
                            bei_misserfolg: item.querySelector(".edit-attack-rw-misserfolg").value || null
                        };
                        // Leere Felder aus dem Rettungswurf-Objekt entfernen
                        Object.keys(attack.rettungswurf).forEach(key => (attack.rettungswurf[key] === null) && delete attack.rettungswurf[key]);
                    }
                    
                    // Nur Angriffe mit einem Namen hinzufügen
                    if (attack.name) {
                        creature.angriffe.push(attack);
                    }
                });

                // Beute speichern (bleibt wie zuletzt besprochen)
                creature.beute = [];
                document.querySelectorAll("#edit-beute-container .loot-editor-item").forEach(item => {
                    const lootRoll = {
                        typ: item.querySelector(".edit-loot-typ").value,
                        beschreibung: item.querySelector(".edit-loot-beschreibung").value,
                        wurf: item.querySelector(".edit-loot-wurf").value
                    };
                    const options = [];
                    item.querySelectorAll(".dynamic-sub-item").forEach(optItem => {
                        const option = {
                            bedingung: optItem.querySelector(".edit-loot-opt-bedingung").value,
                            name: optItem.querySelector(".edit-loot-opt-name").value,
                            anzahl: parseNumberOrNull(optItem.querySelector(".edit-loot-opt-anzahl").value),
                            wert: parseNumberOrNull(optItem.querySelector(".edit-loot-opt-wert").value)
                        };
                        if (option.name && option.bedingung) {
                            options.push(option);
                        }
                    });
                    if (options.length > 0) {
                        lootRoll.optionen = options;
                    } else {
                        lootRoll.wert = parseNumberOrNull(item.querySelector(".edit-loot-wert").value);
                        lootRoll.anzahl = parseNumberOrNull(item.querySelector(".edit-loot-anzahl").value);
                    }
                    if (lootRoll.beschreibung) {
                       creature.beute.push(lootRoll);
                    }
                });

                renderStatblock(creature);
                toggleEditor();
                populateHgFilter();
                filterAndPopulateSidebar();
            }


            function renderEditorForm(creature) {
                return `
                    <div class="form-section">
                        <h4>Allgemein</h4>
                        <div class="form-row">
                            <div class="form-group full"><label for="edit-name">Name</label><input type="text" id="edit-name" value="${creature.name || ""}"></div>
                            <div class="form-group small"><label for="edit-hg">HG</label><select id="edit-hg"></select></div>
                            <div class="form-group medium"><label for="edit-typ">Typ</label><input type="text" id="edit-typ" value="${creature.typ || ""}"></div>
                            <div class="form-group small"><label for="edit-ep">EP</label><input type="number" id="edit-ep" value="${creature.ep || ""}"></div>
                        </div>
                        <div class="form-row">
                            <div class="form-group full"><label for="edit-traits">Traits (Komma-getrennt)</label><input type="text" id="edit-traits" value="${(creature.traits || []).join(", ")}"></div>
                        </div>
                        <div class="form-row">
                            <div class="form-group full"><label for="edit-beschreibung">Beschreibung</label><textarea id="edit-beschreibung">${creature.beschreibung || ""}</textarea></div>
                        </div>
                    </div>

                    <div class="form-section">
                        <h4>Grundwerte</h4>
                        <div class="form-row">
                            <div class="form-group small"><label for="edit-lp">LP</label><input type="number" id="edit-lp" value="${creature.lp || ""}"></div>
                            <div class="form-group medium"><label for="edit-bew">Bewegung</label><input type="text" id="edit-bew" value="${creature.bew || ""}"></div>
                            <div class="form-group small"><label for="edit-ini">INI</label><input type="number" id="edit-ini" value="${creature.ini || ""}"></div>
                        </div>
                    </div>

                    <div class="form-section">
                        <h4>Verteidigung</h4>
                        <div class="form-row">
                            <div class="form-group small"><label for="edit-pa">PA</label><input type="number" id="edit-pa" value="${creature.pa || ""}"></div>
                            <div class="form-group full"><label for="edit-pa-bemerkung">PA Bemerkung</label><input type="text" id="edit-pa-bemerkung" placeholder="Text-Bemerkungen, Semikolon-getrennt"></div>
                            <div class="form-group small"><label for="edit-pa-shield-value">Schild Bonus</label><input type="text" id="edit-pa-shield-value" placeholder="+1"></div>
                            <div class="form-group full"><label for="edit-pa-shield-desc">Schild Beschreibung</label><input type="text" id="edit-pa-shield-desc" placeholder="Holzschild"></div>
                        </div>
                        <div class="form-row">
                            <div class="form-group small"><label for="edit-asw">ASW</label><input type="number" id="edit-asw" value="${creature.asw || ""}"></div>
                            <div class="form-group full"><label for="edit-asw-bemerkung">ASW Bemerkung</label><input type="text" id="edit-asw-bemerkung" value="${creature.asw_bemerkung || ""}"></div>
                        </div>
                        <div class="form-row">
                            <div class="form-group small"><label for="edit-sr">SR</label><input type="number" id="edit-sr" value="${creature.sr || ""}"></div>
                            <div class="form-group full"><label for="edit-sr-bemerkung">SR Bemerkung</label><input type="text" id="edit-sr-bemerkung" value="${creature.sr_bemerkung || ""}"></div>
                        </div>
                    </div>

                    <div class="form-section">
                        <h4>Rettungswürfe</h4>
                        <div class="form-row">
                            <div class="form-group small"><label for="edit-rz">Zähigkeit</label><input type="text" id="edit-rz" value="${creature.rz || ""}"></div>
                            <div class="form-group small"><label for="edit-rr">Reflexe</label><input type="text" id="edit-rr" value="${creature.rr || ""}"></div>
                            <div class="form-group small"><label for="edit-rw">Willenskraft</label><input type="text" id="edit-rw" value="${creature.rw || ""}"></div>
                        </div>
                    </div>

                    <div class="form-section">
                        <h4>Angriffe</h4>
                        <div id="edit-angriffe-container" class="dynamic-section"></div>
                        <button class="add-btn">+ Angriff hinzufügen</button>
                    </div>

                    <div class="form-section">
                        <h4>Besonderheiten</h4>
                        <div id="edit-besonderheiten-container" class="dynamic-section"></div>
                        <button class="add-btn">+ Besonderheit hinzufügen</button>
                    </div>

                    <div class="form-section">
                        <h4>Beute</h4>
                        <div id="edit-beute-container" class="dynamic-section"></div>
                        <button class="add-btn">+ Beute hinzufügen</button>
                    </div>
                `;
            }

            // Hilfsfunktionen
            function txt(x) { return (x === null || x === undefined || x === "") ? "–" : String(x) }
            function plusify(v, isSaveDC = false) {
                if (v === undefined || v === null) return "–";
                if (String(v).toLowerCase() === "immun") return "immun";
                const n = Number(v);
                return isNaN(n) ? String(v) : ((n >= 0 && !isSaveDC ? "+" : "") + n);
            }
            function formatNote(note) { return note ? ` (${note})` : ""; }
            function parseRes(bes) {
                const res = { imm: [], res: [], weak: [], other: [] };
                (bes || []).forEach(s => {
                    const t = String(s || "").trim();
                    if (/^immun/i.test(t)) {
                        let val = t.replace(/^immun(?:ität|itäten)?(?:\s*:\s*|\s+gegen\s*)?/i, "").trim();
                        if (val) res.imm.push(`Immun ${/^gegen\s/i.test(val) ? val : ("gegen " + val)}`);
                    } else if (/^resistenz/i.test(t)) {
                        let val = t.replace(/^resistenzen?|resistenz/i, "").replace(/^(?:\s*:\s*|\s+gegen\s*)?/, "").trim();
                        if (val) res.res.push(`Resistent ${/^gegen\s/i.test(val) ? val : ("gegen " + val)}`);
                    } else if (/^anfälligkeit/i.test(t)) {
                        let val = t.replace(/^anfälligkeiten?|anfälligkeit/i, "").replace(/^(?:\s*:\s*|\s+gegen\s*)?/, "").trim();
                        if (val) res.weak.push(`Anfällig ${/^gegen\s/i.test(val) ? val : ("gegen " + val)}`);
                    } else {
                        res.other.push(t);
                    }
                });
                return res;
            }
            function fmtBew(b) {
                if (!b) return "–";
                const m = b.match(/^(\d+)(?:\s*\((.+)\))?$/);
                if (!m) return b;
                const modes = m[2] ? m[2].replace(/,\s*/g, "; ").replace(/vs/gi, "gegen") : "";
                return modes ? `${m[1]}; ${modes}` : m[1];
            }
            function formatPaNote(paBemerkung) {
                if (!Array.isArray(paBemerkung) || paBemerkung.length === 0) return "";
                const textNotes = paBemerkung.filter(note => typeof note === "string");
                const shieldNote = paBemerkung.find(note => typeof note === 'object' && note.icon === "shield");

                let output = "";
                if (shieldNote) {
                    output += `<span class="icon-shield"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 0c53 0 101.8 20.3 138.1 53.4L499.9 174.1c1.3 1.2 2.3 2.6 3.3 4c16.1 22.4 25.8 49.5 28.8 78.3c4.5 44.1-17.5 87.1-55.2 114.5L283.7 499.9c-11.9 8.9-26.7 12.1-41.8 9.3S211.9 504 201.7 494.7L33.9 370.3C-3.8 342.9-25.8 299.9-21.3 255.8c3-28.8 12.7-55.9 28.8-78.3c.9-1.4 2-2.8 3.3-4L117.9 53.4C154.2 20.3 203 0 256 0zM256 160a96 96 0 1 0 0 192 96 96 0 1 0 0-192z"/></svg>${shieldNote.value}</span>`;
                    if (shieldNote.description) {
                        output += ` (${shieldNote.description})`;
                    }
                }
                if (textNotes.length > 0) {
                    const prefix = shieldNote ? ", " : " ";
                    output += prefix + `(${textNotes.join("; ")})`;
                }
                return output;
            }

            // Neue Funktion: Löschen einer Kreatur
            function deleteCreature(index) {
                if (index === undefined || index < 0 || index >= creatureData.length) return;
                const name = creatureData[index].name || `Kreatur ${index + 1}`;
                creatureData.splice(index, 1);

                // Adjust currentCreatureIndex: try to select the next item if any
                if (creatureData.length === 0) {
                    currentCreatureIndex = -1;
                    $("#out").innerHTML = `<div id="placeholder"><p>${name} wurde gelöscht. Keine Kreaturen vorhanden.</p></div>`;
                } else {
                    const nextIndex = Math.min(index, creatureData.length - 1);
                    currentCreatureIndex = nextIndex;
                    // refresh sidebar and render the newly selected creature if any
                    populateHgFilter();
                    filterAndPopulateSidebar();
                    // Highlight the corresponding list item if present
                    const li = document.querySelector(`#creature-list li[data-index="${currentCreatureIndex}"]`);
                    if (li) {
                        li.classList.add('active');
                    }
                    renderStatblock(creatureData[currentCreatureIndex]);
                }
                populateHgFilter();
                filterAndPopulateSidebar();
                $("#file-name").textContent = `Gesamt: ${creatureData.length} Kreaturen`;
            }

            init();
        });
    </script>
</body>
</html>
