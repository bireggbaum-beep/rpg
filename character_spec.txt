Statblock Spezifikation – Spielcharakter (SC) v0.9
Aufbauend auf v0.8 — vollständige, maschinen- und KI-generatorfreundliche Spezifikation
(Ergänzung: Aktions-/Bewegungsmodell mit Slot‑System & Sprint)

Hinweis: Währung ist ausschließlich Gold (GM). Referenzpreise und Gegenstandswerte stammen aus der Ausrüstungstabelle (siehe Datei) .

==============================
1. Zweck & Grundprinzipien
==============================
Zweck:
- Einheitliche Regeln und eine feste, maschinenlesbare Datenstruktur für die algorithmische Erzeugung von Spielercharakteren (SC) durch eine KI/Generator.
- Primärer Fokus: Erstellung konsistenter Stufe‑1‑Charaktere; Regeln enthalten Support für Level‑Ups (bis mind. Stufe 3+, skalierbar).

Grundprinzipien:
- Algorithmische Generierung: Schritte in Sektion 2 sind verbindlich für den Generator.
- Datenintegrität: Alle abgeleiteten Werte müssen exakt nach Formeln berechnet werden (Abrunden: floor).
- Quellen der Boni: Volk, Beruf, Klasse — getrennt nach Herkunft dokumentiert.

==============================
2. Gesamtablauf / Generator‑Pipeline (verbindlich)
==============================
1. Initialisierung: Attribute = 0.
2. Volk wählen (Menschen: Fokuswahl Sektion 8.1). faehigkeiten.volk eintragen.
3. Beruf wählen. faehigkeiten.beruf eintragen. 1–2 berufsrelevante Startgegenstände markieren.
4. Klasse wählen. faehigkeiten.klasse (Stufe‑1) eintragen.
5. Attributs‑Capping (nur bei Erstellung Stufe 1): clamp(attribute, -1, +3).
6. Abgeleitete Werte berechnen (siehe Sektion 5–7, Rundung: floor).
7. Startausrüstung generieren / Einkauf (siehe Sektion 9).
8. Finale Validierung & Ausgabe (siehe Sektion 14).

==============================
3. Top-Level-JSON-Struktur (Schema)
==============================
{
  "name": "String",
  "spieler": "String",
  "konzept": "String",
  "stufe": Integer,
  "ep": Integer,
  "volk": "String",
  "beruf": "String",
  "klasse": "String",
  "attribute": { "str": Integer, "ges": Integer, "kon": Integer, "int": Integer, "wis": Integer, "cha": Integer },
  "abgeleitete_werte": { "lp_max": Integer, "lp_aktuell": Integer, "ini_bonus": Integer, "bew": Integer },
  "abwehr": { "pa": Integer, "asw": Integer, "sr": { "total": Integer, "quellen":[ { "quelle": "String", "wert": Integer } ] } },
  "rettungswuerfe": { "rz_bonus": Integer, "rr_bonus": Integer, "rw_bonus": Integer },
  "angriffe": [ { "name":"String", "typ":"Nahkampf"|"Fernkampf", "to_hit_bonus": Integer, "schaden_basis": Integer, "bemerkung":"String" } ],
  "faehigkeiten": { "volk": [], "beruf": [], "klasse": [] },
  "ausruestung": [ { "name":"String", "typ":"Waffe"|"Rüstung"|"Schild"|"Anderes", "preis": Integer, "gewicht": Number, "boni":[ { "typ":"PA"|"ASW"|"SR"|"NK_Angriff"|"FK_Angriff"|"RZ"|"RR"|"RW", "wert": Integer, "quelle": "String" } ], "schaden_basis": Integer?, "beschreibung":"String" } ],
  "inventar": [],
  "custom_items": [],
  "waehrung": { "gold": Integer },
  "validation_log": []
}

Bemerkung: "boni" ist optional, wird aber empfohlen. "preis" und "gewicht" müssen bei Ausrüstungsobjekten vorhanden sein.

==============================
4. Attribute (Regeln)
==============================
- Struktur: attribute = { str, ges, kon, int, wis, cha } (Integer).
- Stufe‑1 Erstellung: Startwerte 0 → Addiere Modifikatoren (Volk/Beruf/Klasse) → Capping [-1, +3].
- Stufenanstieg:
  - Spielercharaktere: Spieler wählt frei +1 auf eines der Attribute.
  - KI/Generator: +1 auf ein Attribut, das zum Konzept passt (heuristisch: Klassenpriorität, aber nicht zwingend).
- Alle Änderungen dokumentieren (validation_log).

==============================
5. Abgeleitete Werte (Formeln und Rundung)
==============================
Rundungsregel (bindend):
- Alle Mittelwerte/Divisionen verwenden floor (Abrunden).

Formeln:
- ini_bonus = floor((attribute.ges + attribute.wis) / 2)
- bew = 4 + floor(ini_bonus / 2)
- lp_max (klassenabhängig):
  - Krieger: lp_max = 14 + 2 * (attribute.kon + stufe)
  - Waldläufer / Kleriker: lp_max = 12 + attribute.kon + 2 * stufe
  - Magier: lp_max = 10 + attribute.kon + stufe

lp_aktuell:
- Bei Erstellung: lp_aktuell := lp_max.
- Beim Level‑Up: lp_max neu berechnen; lp_aktuell bleibt unverändert (Generator ändert nicht automatisch).

==============================
6. Abwehr (PA / ASW / SR) — Berechnung & Stacking
==============================
Bonustypen:
- "PA", "ASW", "SR", "NK_Angriff", "FK_Angriff", "RZ", "RR", "RW"

Quellen: Ausrüstung, Fähigkeiten (wenn numerisch), Rassenboni, magische Items. Temporäre Effekte nicht in Basis‑Statblock.

Stacking: Additiv — Summe aller gleichartigen Boni (inkl. negativer Werte).

Berechnungsablauf:
1. pa_basis = 9 + attribute.str
2. asw_basis = 9 + attribute.ges + floor(attribute.wis / 2)
3. Summiere boni aus ausruestung[].boni und faehigkeiten.*[].boni
4. pa = pa_basis + sum(PA-Boni)
5. asw = asw_basis + sum(ASW-Boni)
6. sr.total = sum(SR-Boni)
7. Notiere Quellen im validation_log.

Beispiel: Kettenhemd (SR 3, ASW −1) + Holzschild (PA +1):
- pa = 9 + str + 1
- asw = 9 + ges + floor(wis/2) − 1
- sr.total = 3

==============================
7. Rettungswürfe (Formeln) & Verteidigung gegen Magie
==============================
Formeln (floor):
- rz_bonus = floor((attribute.kon + attribute.str) / 2)
- rr_bonus = floor((attribute.ges + attribute.wis) / 2)
- rw_bonus = floor((attribute.wis + attribute.int) / 2)

Verteidigung gegen magische Angriffe:
- Verteidiger würfelt W20 + passender rettungsbonus.
- Erfolg wenn: W20 + rettungsbonus ≥ Zielwert_total.
- Zielwert_total = Zielwert_basis_des_Effekts + Stufe_des_wirkenden_Magiers.
- Standard ZW_basis (falls nicht spezifiziert): 10 (Empfehlung: Zauber‑Spec definieren).

Bonustypen RZ/RR/RW additiv zu den Basiswerten.

==============================
8. Angriffe (To-Hit & Schaden)
==============================
- to_hit_bonus:
  - Nahkampf: attribute.str + sum(NK_Angriff‑Boni)
  - Fernkampf: attribute.ges + sum(FK_Angriff‑Boni)
- schaden_basis aus Ausrüstungstabelle oder custom_item (z. B. Langschwert Schaden 6).

==============================
9. Startgold & Einkauf (Schritt 7 detailliert)
==============================
Startgold:
- Krieger: 150 + 3W6 × 10 GM  (180 .. 330 GM)
- Waldläufer: 120 + 3W6 × 10 GM (150 .. 300 GM)
- Kleriker: 120 + 3W6 × 10 GM (150 .. 300 GM)
- Magier: 80 + 2W6 × 10 GM (100 .. 200 GM)

Einkaufspriorität: Berufsitems → Waffe → Rüstung/ Schild → Utility → Restgold → waehrung.gold.

==============================
10. Regeln für neu generierte (custom) Items
==============================
- custom_item MUSS: name, typ, preis, gewicht, mechanische Werte, beschreibung, availability.
- Preisbildung: Preis_new = round(median(Referenzpreise) × factor), factor ∈ [0.8, 1.2].
- custom_items protokollieren Referenzen & Preisbildungsmetadaten.

==============================
11. Level‑Up (Stufenanstiege) — Regeln
==============================
- EP‑Schwellen gem. Tabelle (z. B. Stufe2 = 600 EP, Stufe3 = 1400 EP).
- Attributssteigerung: Spielerwahl +1; KI/Generator konzept‑konform.
- Capping nur bei Start Stufe 1.
- LP‑Neuberechnung mit Klassenformel; lp_aktuell unverändert.
- Klassenfähigkeiten automatisch bei Stufen 1, 3, 6, 9 freischalten.

==============================
12. Klassenfähigkeiten — Addendum (Editierbares Modul)
==============================
Format: { "name": "String", "beschreibung": "String", "stufe_erhalten": Integer, "action_type": String?, "uses_reaction": Boolean?, "usage_limit": String? }

(Die bisherigen Fähigkeiten aus v0.8 werden beibehalten — siehe Addendum in v0.8. Weiter unten findet sich die Aktionstyp‑Zuordnung als Beispiel.)

==============================
13. Aktions‑ & Bewegungsmodell (NEU in v0.9) — Slot‑System (verbindlich)
==============================
Kernprinzip:
- Jede Runde stehen pro Charakter folgende Aktions‑Slots zur Verfügung:
  - 1 Bewegungsaktion (Movement Action)
  - 1 Standardaktion (Action; z. B. Angriff, Zauberwirken)
  - 1 Freie Aktion (Free Action; kleine Handlungen, manche Fähigkeiten)
  - 1 Reaktion (Reaction; außerhalb des eigenen Zuges einsetzbar; reset zur eigenen Runde)

Action‑Swap (Sprint / 2 Bewegungsaktionen):
- Ein Charakter darf seine Standardaktion in eine zweite Bewegungsaktion tauschen (Action → Movement Swap). Dadurch hat der Charakter in dieser Runde:
  - 2 Bewegungsaktionen, 0 Standardaktion, 1 Freie Aktion, 1 Reaktion.
- Verwendung: Ermöglicht "Rennen/Sprinten" (siehe Sprint‑Effekt).

Sprint‑Effekt:
- Sprint = Nutzung von zwei Bewegungsaktionen in derselben Runde.
- Effekt: Sprint verdoppelt die normale Bewegungsdistanz in der Runde (Doppelte Distanz).
  - (Genauere Zahlen zur Grundbewegung / Einheiten/Tile‑Größe sind Spielleiter/Map‑Konventionen; Spec stellt die Regel: Sprint → 2× Movement.)

Action‑Kategorien (zuweisen in faehigkeiten.*):
- action_type ∈ { "Freie Aktion", "Aktion", "Große Aktion" }
  - "Freie Aktion" verbraucht die Freie Aktion.
  - "Aktion" verbraucht die Standardaktion.
  - "Große Aktion" verbraucht die Standardaktion und verhindert den Action→Movement Swap (oder alternativ: benötigt zusätzlich Movement, siehe Semantik weiter unten). Standardsemantik (empfohlen): Große Aktion beansprucht den Standardaktion‑Slot und ist vergleichbar mit früher 2 AP; sie verhindert Action→Movement Swap (d.h. du kannst nicht zusätzlich zu dieser großen Aktion eine zweite Movement nehmen).
- uses_reaction: Boolean — wenn true, Fähigkeit verbraucht die Reaktion statt eines Action‑Slots.

Semantik "Große Aktion" (empfohlen):
- Große Aktion beansprucht die Standardaktion. Sie gilt als mächtiger und verhindert, dass der Standardaktion‑Slot in eine Movement‑Slot getauscht wird. (Dies entspricht der Idee: vorherige 2 AP‑Effekte sind mächtiger und verbrauchen/limitieren Bewegungsoptionen.)

Mapping früherer 2‑AP‑Fähigkeiten → "Große Aktion":
- Fähigkeiten, die in früheren Specs 2 AP benötigten (z. B. Geistheilung, Leichte Wunden versorgen), werden action_type = "Große Aktion".

Reaktionen:
- Jede Figur hat 1 Reaktion pro Runde; uses_reaction = true markiert Fähigkeiten, die diese Reaktion verbrauchen (z. B. Stoßschutz, Taktischer Rückzug).
- Reaktionen verbrauchen keine Action‑Slots und werden separat zurückgesetzt.

Bewegung & Reihenfolge:
- Bewegung kann vor/nach/zwischen Aktionen ausgeführt werden, sofern nicht von einer Fähigkeit explizit verboten.
- Falls eine Fähigkeit "verfällt bei Bewegung" (z. B. Zielen), bleibt diese Regel unangetastet.

JSON‑Schema‑Erweiterungen für faehigkeiten.*:
- Optional:
  - "action_type": "Freie Aktion" | "Aktion" | "Große Aktion",
  - "uses_reaction": Boolean,
  - "usage_limit": String (z. B. "3x/Tag", "1x/Begegnung")

Beispiel:
{ "name":"Geistheilung", "beschreibung":"...", "stufe_erhalten":1, "action_type":"Große Aktion", "uses_reaction":false, "usage_limit":"3x/Tag" }
{ "name":"Stoßschutz", "beschreibung":"...", "stufe_erhalten":3, "action_type":null, "uses_reaction":true, "usage_limit":"1x/Kampf" }
{ "name":"Kampf‑Fokus", "beschreibung":"...", "stufe_erhalten":1, "action_type":"Freie Aktion", "uses_reaction":false, "usage_limit":"1x/Begegnung" }

Validation / Logging:
- Wenn Generator setzt action_type, muss dieser Wert gültig sein.
- validation_log protokolliert Action‑Swaps (z. B. "action_swap": "Standard->Movement") und welche Slots Fähigkeiten beanspruchen.

==============================
14. Validierung / Konsistenzchecks (Pflicht)
==============================
Vor Finaler Ausgabe MUSS der Generator prüfen:
- waehrung.gold ≥ 0
- Summe Ausrüstungskosten ≤ Startbudget (Startgold minus Berufsitems)
- attribute sind Integer
- lp_max konsistent mit Klasse und Stufe
- Jedes Ausrüstungsobjekt hat: name, typ, preis, gewicht, mechanische Werte
- Wenn ausruestung[].boni vorhanden: jedes boni-Element hat gültigen "typ" und Integer "wert" (kann negativ sein) und "quelle" string
- validation_log enthält Aufschlüsselung der addierten Boni (Quelle, typ, wert) und bei Bedarf Action‑Swap‑Logs

Optional/Empfohlen:
- Generator legt Änderungsprotokoll an: ["step":"...", "changes":{...}] zur Nachvollziehbarkeit.
- custom_items dokumentieren Referenzen und Preisbildungsformel.

==============================
15. Minimal-Template (aktualisiert JSON)
==============================
{
  "name": "",
  "spieler": "KI",
  "konzept": "",
  "stufe": 1,
  "ep": 0,
  "volk": "",
  "beruf": "",
  "klasse": "",
  "attribute": { "str": 0, "ges": 0, "kon": 0, "int": 0, "wis": 0, "cha": 0 },
  "abgeleitete_werte": { "lp_max": 0, "lp_aktuell": 0, "ini_bonus": 0, "bew": 0 },
  "abwehr": { "pa": 0, "asw": 0, "sr": { "total": 0, "quellen": [] } },
  "rettungswuerfe": { "rz_bonus": 0, "rr_bonus": 0, "rw_bonus": 0 },
  "angriffe": [],
  "faehigkeiten": { "volk": [], "beruf": [], "klasse": [] },
  "ausruestung": [],
  "inventar": [],
  "custom_items": [],
  "waehrung": { "gold": 0 },
  "validation_log": []
}

==============================
16. Implementierungs-Hinweise / Pseudocode-Hints
==============================
- Trennung der Modifikatoren: store volk_modifiers, beruf_modifiers, klasse_modifiers separately.
- Reihenfolge: apply Volk → Beruf → Klasse to attributes.
- Nach Capping (nur wenn stufe == 1) recompute derived values.
- Einkaufsalgorithmus: reserve Berufsitems, then buy Weapon → Armor/Shield → Utility until budget exhausted.
- Bei custom_items: store "reference_basis": [ ids ] and "pricing_factor".
- Runtime: Action‑Slots nicht zwingend persistieren im finalen Statblock, können aber optional in validation_log/runtime_state dokumentiert werden:
  { "runtime_state": { "movement_slots": 1, "action_slots": 1, "free_slots": 1, "reaction_available": 1 } }

==============================
17. Beispiele (Action‑Mapping & Sprint)
==============================
- Geistheilung (Kleriker, aus Addendum): action_type = "Große Aktion", usage_limit = "3x/Tag".
- Leichte Wunden versorgen: action_type = "Große Aktion", usage_limit = "3x/Tag".
- Kampf‑Fokus: action_type = "Freie Aktion", usage_limit = "1x/Begegnung".
- Stoßschutz: uses_reaction = true, usage_limit = "1x/Kampf".
- Zielen (Waldläufer): action_type = "Aktion".
- Sprint: Aktion → Movement Swap → 2 Movement Actions → Movement distance ×2.

==============================
18. Referenzdaten / Beispiele
==============================
- Item‑ & Preisreferenzen sind der Ausrüstungsdatei entnommen (z. B. Langschwert 80 GM, Kettenhemd 140 GM, Holzschild 15 GM).
- Rüstungs‑ASW‑Malusse und Schild‑PA‑Werte müssen vom Generator verwendet werden.

------------------------------
Ende Spec v0.9
------------------------------
